{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "from selenium import webdriver\n",
    "from selenium.webdriver.common.keys import Keys\n",
    "from selenium.webdriver.firefox.firefox_binary import FirefoxBinary\n",
    "from selenium.webdriver.support.ui import WebDriverWait\n",
    "from selenium.webdriver.support import expected_conditions as EC\n",
    "from selenium.webdriver.common.by import By\n",
    "from selenium.common.exceptions import TimeoutException\n",
    "from bs4 import BeautifulSoup\n",
    "import re\n",
    "import pandas as pd\n",
    "import os\n",
    "import datetime"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "http://racing.hkjc.com/racing/Info/Meeting/Results/English/Local/20070909/ST/1\n"
     ]
    },
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-4-bdbded7c1504>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     27\u001b[0m     \u001b[0;31m# Trying to find the presence of a targerted table element after waiting for loading\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     28\u001b[0m     \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 29\u001b[0;31m         \u001b[0mmyElem\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mWebDriverWait\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdriver\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdelay\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0muntil\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mEC\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpresence_of_element_located\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mBy\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mCLASS_NAME\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m'trBgBlue'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     30\u001b[0m         \u001b[0;31m# Printing indicator for the page being ready\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     31\u001b[0m         \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Page is ready!\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/anaconda3/lib/python3.6/site-packages/selenium/webdriver/support/wait.py\u001b[0m in \u001b[0;36muntil\u001b[0;34m(self, method, message)\u001b[0m\n\u001b[1;32m     69\u001b[0m         \u001b[0;32mwhile\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     70\u001b[0m             \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 71\u001b[0;31m                 \u001b[0mvalue\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmethod\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_driver\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     72\u001b[0m                 \u001b[0;32mif\u001b[0m \u001b[0mvalue\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     73\u001b[0m                     \u001b[0;32mreturn\u001b[0m \u001b[0mvalue\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/anaconda3/lib/python3.6/site-packages/selenium/webdriver/support/expected_conditions.py\u001b[0m in \u001b[0;36m__call__\u001b[0;34m(self, driver)\u001b[0m\n\u001b[1;32m     61\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     62\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m__call__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdriver\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 63\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0m_find_element\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdriver\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mlocator\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     64\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     65\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/anaconda3/lib/python3.6/site-packages/selenium/webdriver/support/expected_conditions.py\u001b[0m in \u001b[0;36m_find_element\u001b[0;34m(driver, by)\u001b[0m\n\u001b[1;32m    395\u001b[0m     if thrown.\"\"\"\n\u001b[1;32m    396\u001b[0m     \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 397\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0mdriver\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfind_element\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mby\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    398\u001b[0m     \u001b[0;32mexcept\u001b[0m \u001b[0mNoSuchElementException\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    399\u001b[0m         \u001b[0;32mraise\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/anaconda3/lib/python3.6/site-packages/selenium/webdriver/remote/webdriver.py\u001b[0m in \u001b[0;36mfind_element\u001b[0;34m(self, by, value)\u001b[0m\n\u001b[1;32m    964\u001b[0m         return self.execute(Command.FIND_ELEMENT, {\n\u001b[1;32m    965\u001b[0m             \u001b[0;34m'using'\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mby\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 966\u001b[0;31m             'value': value})['value']\n\u001b[0m\u001b[1;32m    967\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    968\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0mfind_elements\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mby\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mBy\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mID\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mvalue\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/anaconda3/lib/python3.6/site-packages/selenium/webdriver/remote/webdriver.py\u001b[0m in \u001b[0;36mexecute\u001b[0;34m(self, driver_command, params)\u001b[0m\n\u001b[1;32m    316\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    317\u001b[0m         \u001b[0mparams\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_wrap_value\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mparams\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 318\u001b[0;31m         \u001b[0mresponse\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcommand_executor\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mexecute\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdriver_command\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mparams\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    319\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mresponse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    320\u001b[0m             \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0merror_handler\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcheck_response\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mresponse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/anaconda3/lib/python3.6/site-packages/selenium/webdriver/remote/remote_connection.py\u001b[0m in \u001b[0;36mexecute\u001b[0;34m(self, command, params)\u001b[0m\n\u001b[1;32m    470\u001b[0m         \u001b[0mdata\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mutils\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdump_json\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mparams\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    471\u001b[0m         \u001b[0murl\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m'%s%s'\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_url\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpath\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 472\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_request\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcommand_info\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0murl\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbody\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    473\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    474\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m_request\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmethod\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0murl\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbody\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/anaconda3/lib/python3.6/site-packages/selenium/webdriver/remote/remote_connection.py\u001b[0m in \u001b[0;36m_request\u001b[0;34m(self, method, url, body)\u001b[0m\n\u001b[1;32m    494\u001b[0m             \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    495\u001b[0m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_conn\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrequest\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmethod\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mparsed_url\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpath\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbody\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mheaders\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 496\u001b[0;31m                 \u001b[0mresp\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_conn\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mgetresponse\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    497\u001b[0m             \u001b[0;32mexcept\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mhttplib\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mHTTPException\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msocket\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0merror\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    498\u001b[0m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_conn\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mclose\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/anaconda3/lib/python3.6/http/client.py\u001b[0m in \u001b[0;36mgetresponse\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m   1329\u001b[0m         \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1330\u001b[0m             \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1331\u001b[0;31m                 \u001b[0mresponse\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbegin\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1332\u001b[0m             \u001b[0;32mexcept\u001b[0m \u001b[0mConnectionError\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1333\u001b[0m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mclose\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/anaconda3/lib/python3.6/http/client.py\u001b[0m in \u001b[0;36mbegin\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m    295\u001b[0m         \u001b[0;31m# read until we get a non-100 response\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    296\u001b[0m         \u001b[0;32mwhile\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 297\u001b[0;31m             \u001b[0mversion\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstatus\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mreason\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_read_status\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    298\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mstatus\u001b[0m \u001b[0;34m!=\u001b[0m \u001b[0mCONTINUE\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    299\u001b[0m                 \u001b[0;32mbreak\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/anaconda3/lib/python3.6/http/client.py\u001b[0m in \u001b[0;36m_read_status\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m    256\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    257\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m_read_status\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 258\u001b[0;31m         \u001b[0mline\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mstr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mreadline\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0m_MAXLINE\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"iso-8859-1\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    259\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mline\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m>\u001b[0m \u001b[0m_MAXLINE\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    260\u001b[0m             \u001b[0;32mraise\u001b[0m \u001b[0mLineTooLong\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"status line\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/anaconda3/lib/python3.6/socket.py\u001b[0m in \u001b[0;36mreadinto\u001b[0;34m(self, b)\u001b[0m\n\u001b[1;32m    584\u001b[0m         \u001b[0;32mwhile\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    585\u001b[0m             \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 586\u001b[0;31m                 \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_sock\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrecv_into\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mb\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    587\u001b[0m             \u001b[0;32mexcept\u001b[0m \u001b[0mtimeout\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    588\u001b[0m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_timeout_occurred\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "# Reading collected csv file of the dates and location for each race\n",
    "dateList = pd.read_csv('DatesFull.csv')\n",
    "# Setting a Boolean flag indicator for future use for writing to CSV to prevent data loss due to\n",
    "# Program timeouts\n",
    "new = True\n",
    "\n",
    "# Looping over each race date and corrisponding track\n",
    "for index, fullDate in dateList.iterrows():\n",
    "    # Converting and selecting the date in string format\n",
    "    day = str(fullDate['Date'])\n",
    "    # Selecting the track location\n",
    "    tLoc = fullDate['Track']\n",
    "    # Setting the selenium webdriver options to prevent opening new browsers and to initialize\n",
    "    options = webdriver.FirefoxOptions()\n",
    "    options.add_argument('-headless')\n",
    "    driver = webdriver.Firefox(firefox_options=options)\n",
    "    # Creating the URL with the basic information and concating the current date and track location\n",
    "    url = 'http://racing.hkjc.com/racing/Info/Meeting/Results/English/Local/'+day+'/'+tLoc+'/1'\n",
    "    # Printing the URL to check for any errors\n",
    "    print(url)\n",
    "    # Set a wait time for the browser time to open\n",
    "    driver.implicitly_wait(70)\n",
    "    # Provide URL for the page to be pulled\n",
    "    driver.get(url)\n",
    "    # Setting a delay of 5 seconds to allow for javascript load times\n",
    "    delay = 10 # seconds\n",
    "    # Trying to find the presence of a targerted table element after waiting for loading\n",
    "    try:\n",
    "        myElem = WebDriverWait(driver, delay).until(EC.presence_of_element_located((By.CLASS_NAME, 'trBgBlue')))\n",
    "        # Printing indicator for the page being ready\n",
    "        print(\"Page is ready!\")\n",
    "        # Converting the page responce to soup\n",
    "        soup=BeautifulSoup(driver.page_source, 'lxml')        \n",
    "        # Finding how many races were ran that day by first selecting the element containing the race numbers\n",
    "        raceCountBar = soup.find_all(class_='raceNum')\n",
    "        # Testing if no races are found on the webpage\n",
    "        if len(raceCountBar) == 0:\n",
    "            # Printing an indicator that the next date should be accessed\n",
    "            print('next date')\n",
    "        else:\n",
    "            # Finds all of the td elements associated with the race number for the day\n",
    "            raceCount = raceCountBar[0].find_all('td')\n",
    "            # Locating the full track name in the soup\n",
    "            track = raceCount[1].text\n",
    "            # Removing the semicolon from the track\n",
    "            track = track.replace(':','')\n",
    "            # Finding the number of races for the day by counting the elements and subtacting the unassocated elements\n",
    "            raceCount = len(raceCount) - 3\n",
    "            # There are a maximum of 11 races in a day but due to HTML differences testing done if the \n",
    "            # race count is greater than 11 and if so setting it to the max of 11\n",
    "            if raceCount > 11:\n",
    "                raceCount = 11\n",
    "            # Printing the race count for confirmation\n",
    "            print(raceCount)\n",
    "            # Cretaing an empty list for the number of races\n",
    "            numberOfRaces = []\n",
    "            # Initializing a count variable at 0\n",
    "            count = 0\n",
    "            # While loop populates the number of races list when the count is less than the race count\n",
    "            while(count<raceCount):\n",
    "                # Adding 1 to the count\n",
    "                count += 1\n",
    "                # Appending the count to the number of races list\n",
    "                numberOfRaces.append(count)\n",
    "            # Looping over the number of races list \n",
    "            for race in numberOfRaces:\n",
    "                # Creating exact URL for the day, track, and race number \n",
    "                url = 'http://racing.hkjc.com/racing/Info/Meeting/Results/English/Local/'+day+'/'+tLoc+'/'+str(race)\n",
    "                # Printing for URL verification\n",
    "                print(url)\n",
    "                # create a new Firefox session and allow page to load\n",
    "                driver.implicitly_wait(70)\n",
    "                driver.get(url)\n",
    "                delay = 5 # seconds\n",
    "                # Wait for the page to load until specific element is found\n",
    "                try:\n",
    "                    myElem = WebDriverWait(driver, delay).until(EC.presence_of_element_located((By.CLASS_NAME, 'trBgBlue')))\n",
    "                    print(\"Page is ready!\")\n",
    "                    # Turning response into soup\n",
    "                    soup=BeautifulSoup(driver.page_source, 'lxml')\n",
    "                    # Finding the date\n",
    "                    date = soup.find_all(class_ = 'tdAlignL')\n",
    "                    date = date[0].text\n",
    "                    date = re.findall('(\\d+\\S+)', date)\n",
    "                    date = date[0]\n",
    "                    # Finding the race number for the day and overall\n",
    "                    race = soup.find_all(class_ = 'trBgBlue')\n",
    "                    race = race[0].text\n",
    "                    # Finding the type and distance of the race\n",
    "                    raceInfo = soup.find_all(class_ = 'divWidth')\n",
    "                    classDistance = raceInfo[0].text\n",
    "                    # Finding the track condition\n",
    "                    going = raceInfo[0].next_sibling.next_sibling.text\n",
    "                    # Locating addtional info\n",
    "                    moreInfo = raceInfo[0].parent.next_sibling.find_all('td')\n",
    "                    # Finding the handicapper\n",
    "                    handicapper = moreInfo[0].text\n",
    "                    # Finding the course\n",
    "                    course = moreInfo[2].text\n",
    "                    moreInfo = raceInfo[0].parent.next_sibling.next_sibling.find_all('td')\n",
    "                    # Creating an empty list for the winning splits\n",
    "                    cleanWinningSplits = []\n",
    "                    # Locating the winning splits, formatting, and appending\n",
    "                    try:\n",
    "                        winningSplits = [moreInfo[2].text, moreInfo[3].text, moreInfo[4].text]\n",
    "                        for split in winningSplits:\n",
    "                            cleanSplit = split.strip('(')\n",
    "                            cleanSplit = cleanSplit.strip(')')\n",
    "                            cleanWinningSplits.append(cleanSplit)            \n",
    "                    except:\n",
    "                        # If the winning splits are not there all 0s are entered\n",
    "                        cleanWinningSplits = [0,0,0]\n",
    "                    # Locating the prize money and if not found putting unknown in\n",
    "                    try:\n",
    "                        prizeMoney = moreInfo[0].text\n",
    "                    except:\n",
    "                        prizeMoney = 'Unknown'\n",
    "                    # Creating an empty list for the section times\n",
    "                    sectionTime = []\n",
    "                    # Locating the section times, formatting, and appending\n",
    "                    try:\n",
    "                        moreInfo = raceInfo[0].parent.next_sibling.next_sibling.next_sibling.find_all('td')\n",
    "                        sectionTime = [moreInfo[2].text, moreInfo[3].text, moreInfo[4].text]\n",
    "                    except:\n",
    "                        # If the section times are not there all 0s are entered\n",
    "                        sectionTime = [0,0,0]\n",
    "                    # Setting up variables for locating and storing the Class and Distance of the races\n",
    "                    count = 0\n",
    "                    chopSpots = []\n",
    "                    hyphens = 0\n",
    "                    for item in classDistance:\n",
    "                        if item == '-':\n",
    "                            chopSpots.append(count)\n",
    "                            hyphens +=1\n",
    "                        count+= 1\n",
    "                    if hyphens == 1:\n",
    "                        hClass = classDistance[0:chopSpots[0]-1]\n",
    "                        distance = classDistance[chopSpots[0]+2:]\n",
    "                    else:\n",
    "                        hClass = classDistance[0:chopSpots[0]-1]\n",
    "                        distance = classDistance[chopSpots[0]+2:chopSpots[1]]\n",
    "                    # Locating horse information table\n",
    "                    tables = soup.find_all('tbody')\n",
    "                    count = 0\n",
    "                    try:\n",
    "                        rows = tables[4].find_all('tr')\n",
    "                    except:\n",
    "                        rows = tables[3].find_all('tr')\n",
    "                    # Due to variation in formatting the table data is put into list for only specific elements\n",
    "                    resultsPacked = []\n",
    "                    for row in rows:\n",
    "                        data = row.find_all('td')\n",
    "                        tdCount = (len(data))\n",
    "                        if tdCount < 10:\n",
    "                            continue\n",
    "                        else:\n",
    "                            for elem in data:\n",
    "                                if count < 9:\n",
    "                                    resultsPacked.append(elem.text)\n",
    "                                elif count > tdCount-3 :\n",
    "                                    resultsPacked.append(elem.text)\n",
    "                                count +=1\n",
    "                                if count > tdCount-1:\n",
    "                                    count = 0\n",
    "                    # Creating empty lists to store all information for the horses                \n",
    "                    place = []\n",
    "                    horse_num = []\n",
    "                    horse = []\n",
    "                    jockey =[]\n",
    "                    trainer = []\n",
    "                    act_wt = []\n",
    "                    declar_wt = []\n",
    "                    draw = []\n",
    "                    lengs_behind = []\n",
    "                    finish_time = []\n",
    "                    win_odds = []\n",
    "                    count = 0\n",
    "                    # Isolating the required variables based on location in the results packed list\n",
    "                    for x in resultsPacked:\n",
    "                        if count == 0:\n",
    "                            place.append(x)\n",
    "                        elif count == 1:\n",
    "                            horse_num.append(x)\n",
    "                        elif count == 2:\n",
    "                            horse.append(x)\n",
    "                        elif count == 3:\n",
    "                            jockey.append(x)\n",
    "                        elif count == 4:\n",
    "                            trainer.append(x)\n",
    "                        elif count == 5:\n",
    "                            act_wt.append(x)\n",
    "                        elif count == 6:\n",
    "                            declar_wt.append(x)\n",
    "                        elif count == 7:\n",
    "                            draw.append(x)\n",
    "                        elif count == 8:\n",
    "                            lengs_behind.append(x)\n",
    "                        elif count == 9:\n",
    "                            finish_time.append(x)\n",
    "                        elif count == 10:\n",
    "                            win_odds.append(x)\n",
    "                        count = count + 1\n",
    "                        if count == 11:\n",
    "                            count = 0\n",
    "                    # Creating empty lists to store all information for the race \n",
    "                    dateList = []\n",
    "                    raceList = []\n",
    "                    trackList = []\n",
    "                    hClassList = []\n",
    "                    distanceList = []\n",
    "                    goingList = []\n",
    "                    handicapperList = []\n",
    "                    cleanWinningSplitsList = []\n",
    "                    prizeMoneyList = []\n",
    "                    sectionTimeList = []\n",
    "                    # Populating the race info into lists matching the number or horses in the race\n",
    "                    def populateLists(d, r, t, hc, dist, g, h, cWS, pM,\n",
    "                                     sT):\n",
    "                        for x in horse:\n",
    "                            dateList.append(d)\n",
    "                            raceList.append(r)\n",
    "                            trackList.append(t)\n",
    "                            hClassList.append(hc)\n",
    "                            distanceList.append(dist)\n",
    "                            goingList.append(g)\n",
    "                            handicapperList.append(h)\n",
    "                            cleanWinningSplitsList.append(cWS)\n",
    "                            prizeMoneyList.append(pM)\n",
    "                            sectionTimeList.append(sT)\n",
    "\n",
    "                    populateLists(date,race, track, hClass, distance, going,handicapper, cleanWinningSplits, \n",
    "                                  prizeMoney, sectionTime)\n",
    "                    # Build the DataFrame with collected info\n",
    "                    raceDF = pd.DataFrame({'Race':raceList, 'Track':trackList, 'Date':dateList, 'Class': hClassList,\n",
    "                                           'Distance':distanceList, 'Track_Status':goingList, 'Handicapper':handicapperList,\n",
    "                                           'Winning_Splits':cleanWinningSplitsList, 'Prize_Money': prizeMoneyList,\n",
    "                                           'Section_Time':sectionTimeList,\n",
    "                                          'Horse_Number': horse_num,'Horse':horse, 'Jockey':jockey, 'Trainer':trainer,\n",
    "                                          'Act_wt':act_wt, 'Declar_wt':declar_wt, 'Draw':draw, 'Lengs_Behind':lengs_behind,\n",
    "                                        'Finish_Time': finish_time, 'Odds': win_odds, 'Place':place})\n",
    "                    # Testing if the is the first time the dateframe was created\n",
    "                    if(new):\n",
    "                        # Copying the dataframe\n",
    "                        fullDF = raceDF\n",
    "                        # Switching the Boolean value to false\n",
    "                        new = False\n",
    "                    else:\n",
    "                        # Appending the currently created dataframe for the race to existing dataframe of races\n",
    "                        fullDF = fullDF.append(raceDF)\n",
    "                    print(fullDF.shape)\n",
    "                # In the event the page does not load properly printing error message\n",
    "                except TimeoutException:\n",
    "                    print(\"Loading took too much time!\")\n",
    "                # Writing the dataframe to a CSV file \n",
    "                fullDF.to_csv('Races.csv')       \n",
    "    # In the event the page does not load properly printing error message\n",
    "    except TimeoutException:\n",
    "        print(\"Loading took too much time!\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
